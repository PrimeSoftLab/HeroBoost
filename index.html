<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Feed your Soul</title>
<style>

    html, body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #0a0a2e, #1a1a4a);
      color: #fff;
      font-family: 'Rajdhani', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: none;
      min-height: 100vh;
      width: 100%;
      overflow-x: hidden;
    }
    
    h1 {
      font-size: 2.5em;
      color: #4CAF50; /* Solid modern green */
      letter-spacing: 2px;
    }

    canvas {
      background: linear-gradient(160deg, #000428 0%, #0a0a2e 100%);
      margin: 20px 0;
      border: 2px solid #2c2c6b;
      border-radius: 15px;
      touch-action: none;
      max-width: 400px;
      height: 490px;
    }
    
    

    .controls {
      display: flex;
      gap: 15px;
      margin-top: auto;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    button {
      padding: 10px 18px;
      font-size: 14px;
      font-weight: bold;
      background: #4CAF50; /* Modern green */
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      border: 2px solid #45a049; /* Darker green border */
    }

    button:hover {
      background: #45a049;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: scale(0.95);
    }

    #info {
      display: flex;
      justify-content: space-between;
      width: 320px;
      font-size: 18px;
      font-weight: bold;
      padding: 15px;
      margin: 10px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      backdrop-filter: blur(5px);
    }

    #info div span:first-child {
      color: #4CAF50;
      margin-right: 8px;
    }
</style>
</head>
<body>
  <div id="info" style="display: flex; justify-content: space-between; width: 320px; color: red; font-size: 18px; font-weight: bold;">
  <div><span>Duration:</span> <span id="playDuration">00:00</span></div>
  <div><span>Time:</span> <span id="currentTime">:</span></div>
</div>

  <canvas id="game" width="400" height="600"></canvas>
  
  
  
  <div class="controls">
    <button onclick="increaseSpeed()">Speed + </button>
    
    <button onclick="restartGame()">Restart</button>
    
    <button onclick="decreaseSpeed()">Speed - </button>
  </div>
<script>

let startTime = Date.now();

function pad(num) {
  return num.toString().padStart(2, '0');
}

function updateTimeInfo() {
  // Calculate play duration
  const now = Date.now();
  const elapsedMs = now - startTime;
  const elapsedSec = Math.floor(elapsedMs / 1000);
  const minutes = Math.floor(elapsedSec / 60);
  const seconds = elapsedSec % 60;
  document.getElementById("playDuration").textContent = `${pad(minutes)}:${pad(seconds)}`;
  
  // Show current time in 12-hour format with AM/PM
  const date = new Date();
  let hours = date.getHours();
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12;
  hours = hours ? hours : 12; // the hour '0' should be '12'
  const mins = pad(date.getMinutes());
  document.getElementById("currentTime").textContent = `${hours}:${mins} ${ampm}`;
}
// Update time info every second
setInterval(updateTimeInfo, 1000);
updateTimeInfo(); // initial call

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let carX = 100;
let targetCarX = 100;
const carRadius = 15;
let heartTime = 0; 
let obstacles = [];
let gameOver = false;
let score = 0;
const baseBlockHeight = 40;
const padding = 20;
let speed = 3;


// Habit lists (merged and deduplicated)
const badHabits = [
  "Laziness", "Distraction", "Procrastination", "Slang Language", "Negativity", "Non Hygiene", "Negative Thoughts",
  "Scrolling", "Overthinking", "Comparison", "Self-Doubt", "Over Analysis", 
  "Complaining", "Perfectionism", "Overcommitment", "Worrying", "Excuses",
  "Inconsistency", "Jealousy", "Time waste", "Noise", "Dependency",
  "Routineless", "Less Eating", "Fear", "Late Sleep",
  "Addiction", "Disorganize", "Over Regret", "Multitasking",
  "Overload", "Anger", "Pride", "Less Energy", "Greed", "Blaming",
  "Dream Disbelief", "Delay", "Insecurity", "Judgment", "Non Activity",
  "Impatience", "Selfishness", "Dishonesty", "Ignorance", "Shame", "Self guiltiness",
  "Passivity", "Avoidance", "Over Trust", "Frustration", "Careless",
  "Hopeless", "Drifting", "Comfort Attached", "Attachment",
  "Emptiness", "Forgetfulness", "Complacency", "Indecision", "Overspending",
  "Debt",
  "Poor Grooming", "Overworking", "Weak", "Blaming", "Avoiding",  "OverExitment", "Hesitation", "Compromise",
  "Comparing", "Isolating", "Hoarding", "Misprioritizing", "Overcommitting",
  "Underearning", "Negative Vibe", "Poor Attitude", "Comfort zone", "Low Energy",
  "Overconfidence", "Rigid theory", "Bad habit", "Bad Timing", "Confusion", "Ego",
  "Isolation", "Weak tone",
  "Judgemental", "Vagueness", "Mysticism", "Ambiguity", "Repetition",
  "Superstition", "Dry writing", "Controversy", "Apathy", "Bad Mode",
  "Dry style", "Complexity", "Mystical tone", "Harsh tone", "Harsh critique",
  "Intolerance", "Opportunism", "Esotericism", "Sectarianism", "Manipulation", "Mistrust",
   "Early Upsate", "Poor reasoning", "Poor Planning",
  "Closed-mindedness", "Political bias", "Overextension"
];


const goodHabits = [
  "Focus", "Exercise", "Early Rise", "Fearless", "1M+", "1B+", "$500", "$1k", "Productivity", "Energetic", "Smart", "Reflection", "Calmness", 
  "Maturity", "Reading", "Mastery", "Prayer", "Running", "Prepare Food",
  "Travel", "Cycling", "Awareness", "Calorie Calculation", "Task Map",
  "Eat Together", "Help", "Self Care", "Money Planning", "Finance Game", "Hydration", "Journaling",
  "Kindness", "Learning", "Visionary", "Discipline", "Consistency", "Vision",
  "Action", "Strategy", "Patience", "Confidence", "Networking", "Execution",
  "Adaptability", "Persistence", "Innovation", "Leadership", "Curiosity",
  "Optimization", "Delegation", "Resilience", "Commitment", "Mindfulness",
  "Investment", "Budgeting", "Branding", "Marketing", "Selling", "Saving",
  "Risk-taking", "Decision", "Problem-solving", "Negotiation", "Prioritization",
  "Automation", "Collaboration", "Feedback", "Meditation", "Visualization",
  "Decent Sleep", "Energy", "Minimalism", "Generosity", "Integrity", "Boldness",
  "Financial Freedom", "Mentoring", "Gratitude", "Clarity",  "Stillness", "Breathing",
  "Detachment", "Self-talk", "Reframing", "Simplicity", "Movement", "Posture",
  "Nutrition", "Best Calorie", "Stretching", "Sunlight", "Detox", "Strength", "Prosperity", 
  "Earning", "Building", "Frugality", "Scaling Income", "Silence", "Martial Art",
  "Selfie", "Vocal Record", "Forgiveness", "Faith", "Early Sleep", "Pushup",
  "Listen", "Think", "Observe", "Grounding", "Creating", "Disconnecting",
  "Reflecting", "Loving", "Serving", "Walking", "Giving", "Wisdom",
  "Questioning", "Courage", "Self-control", "Idealism", "Justice", "Logic",
  "Order", "Insight", "Passion", "Rationality", "Cheerfulness",
  "Balance", "Peacefulness", "Imagination", "Integration", "Spirituality",
  "Sincerity", "Originality", "Ethics","Objectivity",
  "Poetry", "Love-centered", "Tolerance", "Linguistics", "Chemistry",
  "Dedication", "Optics", "Writing", "Detail", "Research", "Knowledge",
  "Thoughtfulness", "Creativity", "Analysis", "Debate", "Application", "Honesty",
  "Practicality", "Observation", "Quick Decision", "Stylish", "Intelligence", "Systems thinking",
"Math", "Deep thought", "Deep work", "Deep Focus", "Open mind", "Math skills", "Intelligent",
  "Scientific method", "Romantic", "Scientific thought"
];
// Color scheme
const BAD_COLOR = "#4E342E"; // Dark red
const GOOD_COLOR = "#A6243C";
function getTextColor(bgColor) {
  const color = bgColor.replace('#', '');
  const r = parseInt(color.substr(0, 2), 16);
  const g = parseInt(color.substr(2, 2), 16);
  const b = parseInt(color.substr(4, 2), 16);
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5 ? "#000000" : "#ffffff";
}

function drawHabitBlock(obs) {
  ctx.font = "18px Arial";
  const textWidth = ctx.measureText(obs.name).width;
  const blockWidth = textWidth + padding * 2;

  ctx.fillStyle = obs.bgColor;
  ctx.beginPath();
  ctx.roundRect(obs.x, obs.y, blockWidth, baseBlockHeight, [baseBlockHeight / 2]);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.fillStyle = getTextColor(obs.bgColor);
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(obs.name, obs.x + blockWidth / 2, obs.y + baseBlockHeight / 2);
}

// IN THE drawCar() FUNCTION - REPLACE WITH THIS
function drawCar() {
  const heartX = carX + carRadius;
  const heartY = canvas.height - baseBlockHeight - carRadius * 3; // Adjusted vertical position
  const size = carRadius * 2; // Reduced heart size
  const widen = 0.8;
  
  // Draw heart background first
  ctx.fillStyle = "#8B0000";
  ctx.beginPath();
  ctx.moveTo(heartX, heartY + size / 4);
  ctx.bezierCurveTo(
    heartX + size * widen, heartY - size / 2,
    heartX + size * 2 * widen, heartY + size,
    heartX, heartY + size * 1.5
  );
  ctx.bezierCurveTo(
    heartX - size * 2 * widen, heartY + size,
    heartX - size * widen, heartY - size / 2,
    heartX, heartY + size / 4
  );
  ctx.closePath();
  ctx.fill();
  
  // Create clipping path
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(heartX, heartY + size / 4);
  ctx.bezierCurveTo(
    heartX + size * widen, heartY - size / 2,
    heartX + size * 2 * widen, heartY + size,
    heartX, heartY + size * 1.5
  );
  ctx.bezierCurveTo(
    heartX - size * 2 * widen, heartY + size,
    heartX - size * widen, heartY - size / 2,
    heartX, heartY + size / 4
  );
  ctx.closePath();
  ctx.clip();
  
  // Draw animated wave
  ctx.fillStyle = "rgba(220, 20, 60, 0.6)"; // Increased opacity
  ctx.beginPath();
  ctx.moveTo(0, canvas.height);
  
  const waveHeight = 12; // Increased wave height
  const waveLength = 40; // Reduced wavelength
  const yOffset = heartY + Math.sin(heartTime / 40) * 10; // More dramatic movement
  
  for (let x = 0; x <= canvas.width; x++) {
    const y = yOffset + Math.sin((x + heartTime) / waveLength) * waveHeight;
    ctx.lineTo(x, y);
  }
  
  ctx.lineTo(canvas.width, canvas.height);
  ctx.lineTo(0, canvas.height);
  ctx.fill();
  ctx.restore();
  
  // Draw heart outline
  ctx.strokeStyle = "#ff0000";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(heartX, heartY + size / 4);
  ctx.bezierCurveTo(
    heartX + size * widen, heartY - size / 2,
    heartX + size * 2 * widen, heartY + size,
    heartX, heartY + size * 1.5
  );
  ctx.bezierCurveTo(
    heartX - size * 2 * widen, heartY + size,
    heartX - size * widen, heartY - size / 2,
    heartX, heartY + size / 4
  );
  ctx.closePath();
  ctx.stroke();
}

function updateObstacles() {
  obstacles.forEach(obs => obs.y += speed);
  obstacles = obstacles.filter(obs => obs.y < canvas.height);

  for (let i = 0; i < obstacles.length; i++) {
    const obs = obstacles[i];
    const carCenterX = carX + carRadius;
    const carY = canvas.height - baseBlockHeight - carRadius - 5;
    const blockWidth = ctx.measureText(obs.name).width + padding * 2;
    const blockRight = obs.x + blockWidth;
    const blockBottom = obs.y + baseBlockHeight;

    const inX = carCenterX > obs.x && carCenterX < blockRight;
    const inY = carY + carRadius > obs.y && carY - carRadius < blockBottom;

    if (inX && inY) {
      if (obs.isGood) {
        score += 5;
        obstacles.splice(i, 1);
        i--;
      } else {
        gameOver = true;
      }
    }
  }
}

function spawnObstacle() {
  const isGood = Math.random() < 0.4;
  const name = isGood
    ? goodHabits[Math.floor(Math.random() * goodHabits.length)]
    : badHabits[Math.floor(Math.random() * badHabits.length)];

  const bgColor = isGood ? GOOD_COLOR : BAD_COLOR;
  ctx.font = "18px Arial";
  const textWidth = ctx.measureText(name).width;
  const maxX = canvas.width - (textWidth + padding * 2);
  const randomX = Math.floor(Math.random() * maxX);

  obstacles.push({
    x: randomX,
    y: -baseBlockHeight,
    name: name,
    bgColor: bgColor,
    isGood: isGood
  });

  if (!isGood) score++;
}

let spawnDelay = 2000;
let lastSpawn = 0;

function gameLoop(timestamp) {
  if (gameOver) {
    ctx.fillStyle = "#ff0000";
ctx.font = "bold 40px Arial";
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  carX += (targetCarX - carX) * 0.3;
  drawCar();
  heartTime += 2; // Add this line
  
  obstacles.forEach(obs => drawHabitBlock(obs));
  updateObstacles();

  ctx.fillStyle = "#ffffff";
ctx.font = "bold 30px Arial";
ctx.textAlign = "center";
ctx.textBaseline = "top";
ctx.fillText("Score: " + score, canvas.width / 2, 20);

  if (timestamp - lastSpawn > spawnDelay) {
    spawnObstacle();
    lastSpawn = timestamp;
    spawnDelay = Math.max(800, 2000 - score * 30);
  }

  requestAnimationFrame(gameLoop);
}

function restartGame() {
  carX = 100;
  targetCarX = 100;
  obstacles = [];
  gameOver = false;
  score = 0;
  spawnDelay = 2000;
  lastSpawn = 0;
  requestAnimationFrame(gameLoop);
}

canvas.addEventListener("mousemove", function (e) {
  const rect = canvas.getBoundingClientRect();
  targetCarX = e.clientX - rect.left - carRadius;
});

canvas.addEventListener("touchmove", function (e) {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  targetCarX = e.touches[0].clientX - rect.left - carRadius;
});

function increaseSpeed() {
  speed++;
  speedDisplay.innerText = speed;
  speedDisplay2.innerText = speed;
}

function decreaseSpeed() {
  speed = Math.max(1, speed - 1);
  speedDisplay.innerText = speed;
  speedDisplay2.innerText = speed;
}

restartGame();
</script>
</body>
</html>